
New patches:

[unrevert
anon**20140630010822
 Ignore-this: 613072e56e00df796de67e02a8810ad9
] {
hunk ./frag.cabal 86
 
 Executable frag
    Main-is:             Main.hs
-   Build-Depends:       base==4.*, GLUT, OpenGL>=2.0, array, random
+   Build-Depends:       base==4.*
+                      , array
+                      , random
+                      , GLUT
+                      , OpenGL >= 2.9.2.0
+                      , OpenGLRaw >= 1.5.0.0
+                      , hashtables
    Hs-source-dirs:      src
    Ghc-options:         -O2 -funbox-strict-fields -fvia-C -optc-O2
    Extensions:          BangPatterns,
hunk ./src/AFRPVectorSpace.hs 32
 -- be Fractional (roughly a Field) rather than Floating.
 
 -- Minimal instance: zeroVector, (*^), (^+^), dot
-class Floating a => VectorSpace v a | v -> a where
+class (Floating a, Eq a) => VectorSpace v a | v -> a where
     zeroVector   :: v
     (*^)         :: a -> v -> v
     (^/)         :: v -> a -> v
hunk ./src/AFRPVectorSpace.hs 95
 -- Vector space instances for small tuples of Floating
 ------------------------------------------------------------------------------
 
-instance Floating a => VectorSpace (a,a) a where
+instance (Floating a, Eq a) => VectorSpace (a,a) a where
     zeroVector = (0,0)
 
     a *^ (x,y) = (a * x, a * y)
hunk ./src/AFRPVectorSpace.hs 111
     (x1,y1) `dot` (x2,y2) = x1 * x2 + y1 * y2
 
 
-instance Floating a => VectorSpace (a,a,a) a where
+instance (Floating a, Eq a) => VectorSpace (a,a,a) a where
     zeroVector = (0,0,0)
 
     a *^ (x,y,z) = (a * x, a * y, a * z)
hunk ./src/AFRPVectorSpace.hs 127
     (x1,y1,z1) `dot` (x2,y2,z2) = x1 * x2 + y1 * y2 + z1 * z2
 
 
-instance Floating a => VectorSpace (a,a,a,a) a where
+instance (Floating a, Eq a) => VectorSpace (a,a,a,a) a where
     zeroVector = (0,0,0,0)
 
     a *^ (x,y,z,u) = (a * x, a * y, a * z, a * u)
hunk ./src/AFRPVectorSpace.hs 143
     (x1,y1,z1,u1) `dot` (x2,y2,z2,u2) = x1 * x2 + y1 * y2 + z1 * z2 + u1 * u2
 
 
-instance Floating a => VectorSpace (a,a,a,a,a) a where
+instance (Floating a, Eq a) => VectorSpace (a,a,a,a,a) a where
     zeroVector = (0,0,0,0,0)
 
     a *^ (x,y,z,u,v) = (a * x, a * y, a * z, a * u, a * v)
hunk ./src/Camera.hs 13
 import qualified AFRPGeometry as P
 import PhysicalDimensions
 import Graphics.UI.GLUT
+import Control.Applicative
 
 data Camera = Camera {cpos      :: !(Double,Double,Double),
                       viewPos   :: !(Double,Double,Double),
hunk ./src/Camera.hs 30
 
 -- convert from a tuple of doubles to an OpenGL vector
 toVector3 :: Vec3 -> Vector3 GLdouble
-toVector3 (a,b,c) =  Vector3 a b c
+toVector3 (a,b,c) =  realToFrac <$> Vector3 a b c
 
 
 -- convert from a tuple of doubles to an OpenGL vertex
hunk ./src/Camera.hs 35
 toVertex3 :: Vec3 -> Vertex3 GLdouble
-toVertex3 (a,b,c) =  Vertex3 a b c
+toVertex3 (a,b,c) =  realToFrac <$> Vertex3 a b c
 
 
 -- gets OpenGL to assume the view of the camera
hunk ./src/Curves.hs 180
 generateIndices :: Int -> IO (Ptr GLsizei, Ptr (Ptr GLint))
 generateIndices tess = do
    indexArray <- newArray (0,((tess*(tess+1)*2)-1)) 0
-   let pt1 = [ ((((row*(tess+1))+point)*2)+1, fromIntegral ((row*(tess+1))+point)) |
+   let pt1 = [ ((((row*(tess+1))+point)*2)+1, row*(tess+1)+point) |
                          row<-[0..(tess-1)],
                          point<-[0..tess]]
hunk ./src/Curves.hs 183
-   let pt2 = [ ((((row*(tess+1))+point)*2), fromIntegral (((row+1)*(tess+1))+point)) |
+   let pt2 = [ ((((row*(tess+1))+point)*2), (row+1)*(tess+1)+point) |
                          row<-[0..(tess-1)],
                          point<-[0..tess]]
    mapM_ (writeIndices indexArray) pt1
hunk ./src/Curves.hs 200
 
 
 -- writes the indices to memory
-writeIndices :: IOUArray Int GLint -> (Int,GLint) -> IO ()
+writeIndices :: IOUArray Int Int -> (Int, Int) -> IO ()
 writeIndices indcs (pos,content) = writeArray indcs pos content
hunk ./src/Frustum.hs 12
 
 import Graphics.UI.GLUT
 import Graphics.Rendering.OpenGL.GL.CoordTrans
+--import Foreign.C.Types (CDouble(CDouble))
+import Prelude hiding (concat)
+import Data.Foldable (concat)
 
 
 type FPlane =  (Double, Double, Double, Double)
hunk ./src/Frustum.hs 36
     m10,m11,m12,m13,
     m20,m21,m22,m23,
     m30,m31,m32,m33] <- getMatrixComponents ColumnMajor mvMatrix
+    --- XXX get this to work rather than the spam below. getMatricComponents :: MatrixOrder -> m c -> IO [c]
+    --m30,m31,m32,m33] <- map (realToFrac) $ concat ( getMatrixComponents ColumnMajor mvMatrix)
    pjMatrix <- get (matrix (Just (Projection))) :: IO (GLmatrix GLdouble)
    [p00,p01,p02,p03,
     p10,p11,p12,p13,
hunk ./src/Frustum.hs 43
     p20,p21,p22,p23,
     p30,p31,p32,p33] <- getMatrixComponents ColumnMajor pjMatrix
+    --p30,p31,p32,p33] <- map (realToFrac) $ concat ( getMatrixComponents ColumnMajor pjMatrix)
 
    let clip00 = m00*p00 + m01*p10 + m02*p20 + m03*p30
    let clip01 = m00*p01 + m01*p11 + m02*p21 + m03*p31
hunk ./src/Frustum.hs 65
    let clip32 = m30*p02 + m31*p12 + m32*p22 + m33*p32
    let clip33 = m30*p03 + m31*p13 + m32*p23 + m33*p33
 
-   let rightX = clip03 - clip00
-   let rightY = clip13 - clip10
-   let rightZ = clip23 - clip20
-   let rightD = clip33 - clip30
+   let rightX = realToFrac $ clip03 - clip00
+   let rightY = realToFrac $ clip13 - clip10
+   let rightZ = realToFrac $ clip23 - clip20
+   let rightD = realToFrac $ clip33 - clip30
 
hunk ./src/Frustum.hs 70
-   let leftX  = clip03 + clip00
-   let leftY  = clip13 + clip10
-   let leftZ  = clip23 + clip20
-   let leftD  = clip33 + clip30
+   let leftX  = realToFrac $ clip03 + clip00
+   let leftY  = realToFrac $ clip13 + clip10
+   let leftZ  = realToFrac $ clip23 + clip20
+   let leftD  = realToFrac $ clip33 + clip30
 
hunk ./src/Frustum.hs 75
-   let bottomX  = clip03 + clip01
-   let bottomY  = clip13 + clip11
-   let bottomZ  = clip23 + clip21
-   let bottomD  = clip33 + clip31
+   let bottomX  = realToFrac $ clip03 + clip01
+   let bottomY  = realToFrac $ clip13 + clip11
+   let bottomZ  = realToFrac $ clip23 + clip21
+   let bottomD  = realToFrac $ clip33 + clip31
 
hunk ./src/Frustum.hs 80
-   let topX  = clip03 - clip01
-   let topY  = clip13 - clip11
-   let topZ  = clip23 - clip21
-   let topD  = clip33 - clip31
+   let topX  = realToFrac $ clip03 - clip01
+   let topY  = realToFrac $ clip13 - clip11
+   let topZ  = realToFrac $ clip23 - clip21
+   let topD  = realToFrac $ clip33 - clip31
 
hunk ./src/Frustum.hs 85
-   let backX  = clip03 - clip02
-   let backY  = clip13 - clip12
-   let backZ  = clip23 - clip22
-   let backD  = clip33 - clip32
+   let backX  = realToFrac $ clip03 - clip02
+   let backY  = realToFrac $ clip13 - clip12
+   let backZ  = realToFrac $ clip23 - clip22
+   let backD  = realToFrac $ clip33 - clip32
 
hunk ./src/Frustum.hs 90
-   let frontX  = clip03 + clip02
-   let frontY  = clip13 + clip12
-   let frontZ  = clip23 + clip22
-   let frontD  = clip33 + clip32
+   let frontX  = realToFrac $ clip03 + clip02
+   let frontY  = realToFrac $ clip13 + clip12
+   let frontZ  = realToFrac $ clip23 + clip22
+   let frontD  = realToFrac $ clip33 + clip32
 
    rightPlane  <- normalisePlane (rightX ,rightY ,rightZ ,rightD)
    leftPlane   <- normalisePlane (leftX  ,leftY  ,leftZ  ,leftD)
hunk ./src/Matrix.hs 74
 
 -- Makes a Vertex3 (GLdouble) from a Vec3
 vert::Vec3->Vertex3(GLdouble)
-vert (x,y,z) = Vertex3 x y z
+vert (x,y,z) = Vertex3 (realToFrac x) (realToFrac y) (realToFrac z)
 
 -- Makes a TexCoord2 (GLdouble) from a Vec3
 coord::(Double,Double)->TexCoord2(GLdouble)
hunk ./src/Matrix.hs 78
-coord (x,y) = TexCoord2 x y
+coord (x,y) = TexCoord2 (realToFrac x) (realToFrac y)
 
 -- Makes a Vector3 (GLdouble) from a Vec3
 vect::Vec3->Vector3(GLdouble)
hunk ./src/Matrix.hs 82
-vect (x,y,z) = Vector3 x y z
+vect (x,y,z) = Vector3 (realToFrac x) (realToFrac y) (realToFrac z)
 
 -- Makes a Normal3 (GLdouble) from a Vec3
 norm3::Vec3->Normal3(GLdouble)
hunk ./src/Matrix.hs 86
-norm3 (x,y,z) = Normal3 x y z
+norm3 (x,y,z) = Normal3 (realToFrac x) (realToFrac y) (realToFrac z)
hunk ./src/Quaternion.hs 11
 
 module Quaternion where
 
-import Graphics.UI.GLUT -- (GLmatrix, GLfloat, newMatrix, ColumnMajor)
+import Graphics.UI.GLUT
+import Control.Applicative
 
 type Quaternion = (Float,Float,Float,Float)
 
hunk ./src/Quaternion.hs 23
 -- converts from quaternion to matrix
 quat2Mat :: Quaternion -> (Float,Float,Float) -> IO (GLmatrix GLfloat)
 quat2Mat (x,y,z,w) (t1,t2,t3)=
-   newMatrix ColumnMajor [(r00 :: GLfloat),r01,r02,r03,
-                          r10,r11,r12,r13,
-                          r20,r21,r22,r23,
-                          r30,r31,r32,r33]
+   newMatrix ColumnMajor $ realToFrac <$> [r00,r01,r02,r03,
+                                           r10,r11,r12,r13,
+                                           r20,r21,r22,r23,
+                                           r30,r31,r32,r33]
    where r00 = 1 - (2*((y*y)+(z*z)))
          r01 = 2 * ((x*y)-(w*z))
          r02 = 2 * ((x*z)+(w*y))
hunk ./src/Render.hs 12
 
 import MD3
 import Object
-import Graphics.Rendering.OpenGL
+import Graphics.Rendering.OpenGL hiding (vertex, rotate)
+import qualified Graphics.Rendering.OpenGL as GRO
 import Data.IORef
 import Data.Maybe
 import Camera
hunk ./src/Render.hs 23
 import Data.HashTable
 import Visibility
 import TextureFonts
+import Control.Applicative
+
+-- The redefinitions of matrix transform functions here are needed because
+-- putting type specifications in every line they're used is not a sane
+-- alternative. The problem stems from the fact that most of the Haskell code
+-- maintains Floats and Doubles and the type system cannot automatically
+-- resolve conversions made by fromIntegral or realToFrac because they take
+-- place within monadic function calls.
+vertex :: Vertex3 Double -> IO ()
+vertex v = GRO.vertex (realToFrac <$> v :: Vertex3 GLdouble)
+
+rotate :: Double -> Vector3 Double -> IO ()
+rotate angle v = GRO.rotate (realToFrac angle :: GLdouble) (realToFrac <$> v :: Vector3 GLdouble)
+-- TODO: other redefinitions should follow, wherever repeated type specifiers are used in this module.
+
 
 data GameData = GameData {
                             gamemap        :: IORef(BSPMap),
hunk ./src/Render.hs 153
           clear [DepthBuffer ]
 
           --translate and rotate the gun so it is aligned with players view vector
-          translate (Vector3 x (y+30) (z :: Double))
+          translate (Vector3 (realToFrac x) (realToFrac (y+30)) (realToFrac z) :: Vector3 GLfloat)
           let angle2 =
                     acos $ dotProd (normalise $ vectorSub (vx,0,vz) (x,0,z)) (1,0,0)
           case (vz > z ) of
hunk ./src/Render.hs 157
-                False -> rotate ((angle2*180/pi) :: GLdouble) (Vector3 0 1 0)
-                True  -> rotate ((360 - (angle2*180/pi)) :: GLdouble) (Vector3 0 1 0)
+                False -> rotate (angle2*180/pi) (Vector3 0 1 0)
+                True  -> rotate (360 - (angle2*180/pi)) (Vector3 0 1 0)
           let angle1 =
                     acos $ dotProd (normalise $ vectorSub (vx,vy,vz) (x,y,z)) (0,1,0)
hunk ./src/Render.hs 161
-          rotate (90-(angle1*180/pi) :: GLdouble) (Vector3 0 0 1)
-          rotate (-90 :: Double) (Vector3 1 0 0)
-          translate (Vector3 (4.8) (-9.5) ((-20) :: Double))
+          rotate (90-(angle1*180/pi)) (Vector3 0 0 1)
+          rotate (-90) (Vector3 1 0 0)
+          translate (Vector3 (realToFrac 4.8) (realToFrac $ -9.5) (realToFrac $ -20) :: Vector3 GLfloat)
           scale 2 2 (2 :: GLfloat)
 
           --setup the animation state and drw the model
hunk ./src/Render.hs 171
           drawModel (modelRef weapon,lowerState weapon)
    depthFunc              $= Just Always
 
-
 renderRay :: ObsObjState -> IO()
 renderRay (OOSRay {rayStart = (x1,y1,z1),
                             rayEnd   = (x2,y2,z2),
hunk ./src/Render.hs 179
     color $ Color4 255 0 0 (255 :: GLubyte)
     depthFunc              $= Just Always
     unsafeRenderPrimitive Quads $ do
-          vertex (Vertex3 x2 (y2+0.3) z2)
-          vertex (Vertex3 x2 (y2-0.3) z2)
-          vertex (Vertex3 x1 (y1-0.3) z1)
-          vertex (Vertex3 x1 (y1+0.3) z1)
+          vertex $ Vertex3 x2 (y2+0.3) z2
+          vertex $ Vertex3 x2 (y2-0.3) z2
+          vertex $ Vertex3 x1 (y1-0.3) z1
+          vertex $ Vertex3 x1 (y1+0.3) z1
     color $ Color4 255 255 255 (255 :: GLubyte)
     unsafeRenderPrimitive Quads $ do
hunk ./src/Render.hs 185
-          vertex (Vertex3 x2 (y2+0.12) z2)
-          vertex (Vertex3 x2 (y2-0.12) z2)
-          vertex (Vertex3 x1 (y1-0.12) z1)
-          vertex (Vertex3 x1 (y1+0.12) z1)
+          vertex $ Vertex3 x2 (y2+0.12) z2
+          vertex $ Vertex3 x2 (y2-0.12) z2
+          vertex $ Vertex3 x1 (y1-0.12) z1
+          vertex $ Vertex3 x1 (y1+0.12) z1
     depthFunc              $= Just Less
     cullFace               $= Just Front
     case cl of
hunk ./src/Render.hs 195
           True -> do
                 cullFace                    $= Nothing
                 unsafePreservingMatrix $ do
-                   translate (Vector3 x2 y2 z2)
+                   translate (Vector3 (realToFrac x2 :: GLfloat) (realToFrac y2) (realToFrac z2))
                    renderQuadric
                          (QuadricStyle Nothing NoTextureCoordinates Outside FillStyle)
                             (Sphere 3 12 12)
hunk ./src/Render.hs 207
 renderProjectile :: ObsObjState -> IO()
 renderProjectile (OOSProjectile {projectileOldPos = (x,y,z)}) = do
    unsafePreservingMatrix $ do
-         translate (Vector3 x y z)
+         translate (Vector3 (realToFrac x :: GLfloat) (realToFrac y) (realToFrac z))
          depthFunc              $= Just Always
          cullFace               $= Nothing
          color $ Color4 0 0 80 (255 :: GLubyte)
hunk ./src/Render.hs 258
                         _ -> do
                            unsafePreservingMatrix $ do
                                  lineWidth $= 5.0
-                                 translate (Vector3 x y z)
+                                 translate (Vector3 (realToFrac x) (realToFrac y) (realToFrac z) :: Vector3 GLdouble)
                                  Just model <- Data.HashTable.lookup mdels name
                                  writeIORef (pitch model)
                                     (Just $ do
hunk ./src/Render.hs 264
                                                     cullFace $=  Nothing
                                                     cullFace $=  Just Front
-                                                    (rotate p (Vector3 0 1 0)))
+                                                    rotate p (Vector3 0 1 0))
                                  writeIORef (lowerState model)  la
                                  writeIORef (upperState model)  ua
hunk ./src/Render.hs 267
-                                 currentColor $= Color4 (f*60) (f*60) (f*60) (1 :: Float)
+                                 currentColor $= (Color4 (realToFrac f*60) (realToFrac f*60) (realToFrac f*60) 1 :: Color4 GLfloat)
                                  unsafePreservingMatrix $ do
hunk ./src/Render.hs 269
-                                    rotate ((-90) :: GLdouble) (Vector3 1 0 0)
-                                    rotate (angle) (Vector3 0 0 1)
-                                    translate (Vector3 (-10) 0 (-10 :: Double))
+                                    rotate (-90) (Vector3 1 0 0)
+                                    rotate angle (Vector3 0 0 1)
+                                    translate (Vector3 (-10) 0 (-10 :: GLdouble))
                                     scale 1.5 1.5 (1.5 :: GLfloat)
                                     drawModel (modelRef model,lowerState model)
hunk ./src/Render.hs 274
-                                 currentColor $= Color4 1 1 1 (1 :: Float)
+                                 currentColor $= Color4 1 1 1 (1 :: GLfloat)
                                  writeIORef (pitch model) Nothing
             False -> return ()
hunk ./src/Render.hs 277
+
hunk ./src/TextureFonts.hs 37
 
 
 -- the steps needed to display every font
-genFontList :: ((Float,Float),DisplayList) -> IO()
+genFontList :: ((GLfloat,GLfloat),DisplayList) -> IO()
 genFontList ((cx,cy),list) = do
    defineList list Compile $ do
      unsafeRenderPrimitive Quads $ do
hunk ./src/TextureFonts.hs 42
          texCoord (TexCoord2 cx (1-cy-0.0625))
-         vertex   (Vertex2 0 (16 :: Float))
+         vertex   (Vertex2 0 16 :: Vertex2 GLfloat)
          texCoord (TexCoord2 (cx+0.0625) (1-cy-0.0625))
hunk ./src/TextureFonts.hs 44
-         vertex   (Vertex2 16 (16 :: Float))
+         vertex   (Vertex2 16 16 :: Vertex2 GLfloat)
          texCoord (TexCoord2 (cx+0.0625) (1-cy-0.001))
hunk ./src/TextureFonts.hs 46
-         vertex   (Vertex2 16 (0 :: Float))
+         vertex   (Vertex2 16 0 :: Vertex2 GLfloat)
          texCoord (TexCoord2 cx (1-cy-0.001))
hunk ./src/TextureFonts.hs 48
-         vertex   (Vertex2 0 (0 :: Float))
-     translate (Vector3 (14 :: Float) 0 0)
+         vertex   (Vertex2 0 0 :: Vertex2 GLfloat)
+     translate (Vector3 14 0 0 :: Vector3 GLfloat)
 
 
 -- generates a displaylist for displaying large digits
hunk ./src/TextureFonts.hs 67
    defineList list Compile $ do
       textureBinding Texture2D $= tex
       unsafeRenderPrimitive Quads $ do
-         texCoord (TexCoord2  0 ( 1 :: Float))
-         vertex   (Vertex2    0 ( 0 :: Float))
-         texCoord (TexCoord2  0 ( 0 :: Float))
-         vertex   (Vertex2    0 (45 :: Float))
-         texCoord (TexCoord2  1 ( 0 :: Float))
-         vertex   (Vertex2   30 (45 :: Float))
-         texCoord (TexCoord2  1 ( 1 :: Float))
-         vertex   (Vertex2   30 ( 0 :: Float))
-      translate   (Vector3 (32 :: Float) 0 0)
+         texCoord (TexCoord2  0  1 :: TexCoord2 GLfloat)
+         vertex   (Vertex2    0  0 :: Vertex2 GLfloat)
+         texCoord (TexCoord2  0  0 :: TexCoord2 GLfloat)
+         vertex   (Vertex2    0 45 :: Vertex2 GLfloat)
+         texCoord (TexCoord2  1  0 :: TexCoord2 GLfloat)
+         vertex   (Vertex2   30 45 :: Vertex2 GLfloat)
+         texCoord (TexCoord2  1  1 :: TexCoord2 GLfloat)
+         vertex   (Vertex2   30  0 :: Vertex2 GLfloat)
+      translate   (Vector3 32 0 0 :: Vector3 GLfloat)
 
 
 -- renders a large digit
hunk ./src/TextureFonts.hs 83
 renderNum x y (DisplayList base) n = unsafePreservingMatrix $ do
    loadIdentity
    texture Texture2D $= Enabled
-   alphaFunc $= Just (Greater,0.1:: Float)
+   alphaFunc $= Just (Greater,0.1)
    let list = map toDList (show n)
    unsafePreservingMatrix $ do
hunk ./src/TextureFonts.hs 86
-      translate (Vector3 x y (0::Float))
+      translate (Vector3 (realToFrac x) (realToFrac y) 0 :: Vector3 GLfloat)
       mapM_ callList list
    alphaFunc $= Nothing
    texture Texture2D $= Disabled
hunk ./src/TextureFonts.hs 103
       loadIdentity
       texture Texture2D $= Enabled
       textureBinding Texture2D $= fontTex
-      translate (Vector3 x y (0::Float))
+      translate (Vector3 (realToFrac x) (realToFrac y) 0 :: Vector3 GLfloat)
       let lists = map (toDisplayList (128*(fromIntegral st))) string
hunk ./src/TextureFonts.hs 105
-      alphaFunc $= Just (Greater,0.1:: Float)
+      alphaFunc $= Just (Greater,0.1)
       mapM_ callList lists --(map DisplayList [17..(32:: GLuint)])
       alphaFunc $= Nothing
       texture Texture2D $= Disabled
hunk ./src/TextureFonts.hs 132
    textureBinding Texture2D $= crosshairTex
    unsafePreservingMatrix $ do
       loadIdentity
-      translate (Vector3 304 224 (0::Float))
-      alphaFunc $= Just (Greater,0.1:: Float)
+      translate (Vector3 304 224 0 :: Vector3 GLfloat)
+      alphaFunc $= Just (Greater,0.1)
       unsafeRenderPrimitive Quads $ do
hunk ./src/TextureFonts.hs 135
-         texCoord (TexCoord2 0 (1 :: Float))
-         vertex   (Vertex2 0 (0 :: Float))
-         texCoord (TexCoord2 0 (0 :: Float))
-         vertex   (Vertex2 0 (32 :: Float))
-         texCoord (TexCoord2 1 (0 :: Float))
-         vertex   (Vertex2 32 (32 :: Float))
-         texCoord (TexCoord2 1 (1 :: Float))
-         vertex   (Vertex2 32 (0 :: Float))
+         texCoord (TexCoord2 0 1 :: TexCoord2 GLfloat)
+         vertex   (Vertex2 0 0 :: Vertex2 GLfloat)
+         texCoord (TexCoord2 0 0 :: TexCoord2 GLfloat)
+         vertex   (Vertex2 0 32 :: Vertex2 GLfloat)
+         texCoord (TexCoord2 1 0 :: TexCoord2 GLfloat)
+         vertex   (Vertex2 32 32 :: Vertex2 GLfloat)
+         texCoord (TexCoord2 1 1 :: TexCoord2 GLfloat)
+         vertex   (Vertex2 32 0 :: Vertex2 GLfloat)
       alphaFunc $= Nothing
    texture Texture2D $= Disabled
 
hunk ./src/Textures.hs 13
 import TGA (readTga)
 import Data.Word (Word8)
 import Foreign.Marshal.Alloc (free)
+import Control.Exception (catch)
+import Control.Exception.Base (SomeException)
 
 
 -- read a list of images and returns a list of textures
hunk ./src/Textures.hs 37
 
 -- read the image data
 readImageC :: String -> IO (Maybe (Size, PixelData Word8))
-readImageC path = catch (readTga path) (\_ -> do print ("missing texture: "++path)
-                                                 return Nothing)
+readImageC path = catch (readTga path) (\e -> let _ = (e :: SomeException) in do 
+                                              putStrLn $ "missing texture: "++path
+                                              return Nothing)
 
 
 -- creates the texture
}

Context:

[bump to base 4
Don Stewart <dons@galois.com>**20081011185656] 
[Port to GHC 6.10
Don Stewart <dons@galois.com>**20081011185622] 
[Build just the binary (not the library)
Don Stewart <dons@galois.com>**20080622224249] 
[modern setup.hs
Don Stewart <dons@galois.com>**20080622223500] 
[dehaskell98
gwern0@gmail.com**20080224215754] 
[Initial import of frag 1.1
Don Stewart <dons@galois.com>**20080129194811] 
Patch bundle hash:
2e6162bb4e17f24cb41d3791bd45764887a76a52
